---
title: "developpement_fonctions-libreSQE"
format: pdf
editor: visual
---

## Chargement du fichier xml

On utilise pour l'instant la fonction import_QESU_PHY_v3 de tools4DCE. Cette fonction devra être remaniée pour être + rapide et intégrer les champs facultatifs (ex. le nom des stations de mesures ou la date de réception des échantillons).

```{r}
# calendaire UGVE septembre
fichier<-"C:\\Users\\anthony.deburghrave\\OneDrive - EPTB Vilaine\\Documents\\suivis EPTB\\2022\\marché et commande\\05_livrables\\QUESU3_EPTB_VILAINE-CAB_2022-08-02_0400003224\\QUESU3_EPTB_VILAINE-CAB_2022-09-07_0400003223.xml"


# pluie UGVE aout
fichier<-"C:\\Users\\anthony.deburghrave\\OneDrive - EPTB Vilaine\\Documents\\suivis EPTB\\2022\\marché et commande\\05_livrables\\QUESU3_EPTB_VILAINE-CAB_2022-08-02_0400003224\\QUESU3_EPTB_VILAINE-CAB_2022-08-17_0400003223.xml"

param_perimetre_facturation<-"UGVE" 
param_rattachement_bdc <- "pluie" 
param_mois <- "aout"

# pluie UGVO avril
fichier<-"C:\\Users\\anthony.deburghrave\\OneDrive - EPTB Vilaine\\Documents\\suivis EPTB\\2022\\marché et commande\\05_livrables\\QUESU3_EPTB_VILAINE-CAB_2022-08-02_0400003224\\QUESU3_EPTB_VILAINE-CAB_2022-08-17_0400003223.xml"

# file.choose()

param_perimetre_facturation<-"UGVO - VHBC" 
param_rattachement_bdc <- "pluie" 
param_mois <- "avril"


library(tools4DCE)
library(tidyverse)
fichier_xml<-import_QESU_PHY_v3(fichier)
analyses_xml<-fichier_xml$analyses
cond_environ_xml<-fichier_xml$cond_env
operations_xml<-fichier_xml$operations

```

## Chargement du programme global

Le programme global est inclus dans un fichier EXCEl qui respecte les dénominations d'onglet du fichier exemple.

#### Onglet prog_annuelle

Cet onglet résume le nombre de prestations annuelles par station.

Dans l'onglet prog_annuelle, les noms de colonnes avec des programmes types doivent débuter par "PT" suivi du nom du programme type (ex. PT PC BASE pour le programme PC BASE).

Les noms des prestations de prélèvement doivent débuter par "PREL".

```{r}

library(readxl)

fichier_prog<-"C:\\workspace\\LibreSQE\\dev\\fichier_exemple_commande\\v2 prog EPTB Est_Ouest 2022 - commande_3 derniers trimestres_ajout suivis Captages_version dev libreSQE.xlsx"

prog_annuelle<-read_xlsx(fichier_prog,
                         sheet="programme_annuel",
                         col_types = "text")


calendrier<-read_xlsx(fichier_prog,
                         sheet="calendrier")


programmes_types<-read_xlsx(fichier_prog,
                         sheet="programmes_types")


BPU<-read_xlsx(fichier_prog,
                         sheet="BPU")


cout_run_analytiques<-read_xlsx(fichier_prog,
                         sheet="cout_run_analytiques")


```

## Construction du programme prévisionnel

On croise type de station, périmètre de facturation, préleveur et rattachement bdc (pluie ou calendaire) pour pré-établir des bdc mensuels par périmètre de facturation.

Les prestations prévus dans chaque bdc mensuels peuvent ensuite être complétées "à la main" avec les prestations type fourniture de flaconnage, transport, réunions, ...

```{r}


prog_previsionnelle <-
  left_join(prog_annuelle,
            calendrier,
            by = c("type_station"))


prog_previsionnelle <- pivot_longer(prog_previsionnelle,
                                    janvier:décembre,
                                    names_to = "mois",
                                    values_to = "quantite_commandee")

prog_previsionnelle <-
  prog_previsionnelle %>% subset(quantite_commandee > 0)


prog_previsionnelle_annuelle<-
  left_join(prog_previsionnelle, 
             programmes_types,
             by="programme")

prog_previsionnelle_annuelle<-
  left_join(prog_previsionnelle_annuelle, 
             cout_run_analytiques,
             by="run_analytique")

# bdc <-
#   prog_previsionnelle %>% subset(
#     perimetre_facturation == param_perimetre_facturation &
#       rattachement_bdc == param_rattachement_bdc & mois == param_mois
#   )
# 
# analyses_attendues_bdc <-
#   left_join(bdc, programmes_types, by = "programme")
# 
# analyses_attendues_bdc <-
#   left_join(analyses_attendues_bdc, 
#             cout_run_analytiques,
#             by=c("run_analytique"))
```

## Comparaison rendu / prévisionnel

#### Stations manquantes

On compare les stations attendues avec celles dans le fichier de résultat d'analyses.

```{r}

liste_cd_station_abs_analyses<-analyses_attendues_bdc$`CODE SANDRE STATION`[!(analyses_attendues_bdc$`CODE SANDRE STATION`%in%analyses_xml$CdStationMesureEauxSurface)]%>%unique()

station_manquant<-data.frame(CdStationMesureEauxSurface=liste_cd_station_abs_analyses)
station_manquant<-ajoute_nom_station(station_manquant)

station_manquant

```

Idem dans conditions environnementales

```{r}
liste_cd_station_abs_analyses<-analyses_attendues_bdc$`CODE SANDRE STATION`[!
analyses_attendues_bdc$`CODE SANDRE STATION`%in%cond_environ_xml$CdStationMesureEauxSurface]%>%unique()

manquant<-data.frame(CdStationMesureEauxSurface=liste_cd_station_abs_analyses)
manquant<-ajoute_nom_station(manquant)

manquant

```

Idem dans opérations

```{r}
liste_cd_station_abs_analyses<-analyses_attendues_bdc$`CODE SANDRE STATION`[!analyses_attendues_bdc$`CODE SANDRE STATION`%in%operations_xml$CdStationMesureEauxSurface]%>%unique()

manquant<-data.frame(CdStationMesureEauxSurface=liste_cd_station_abs_analyses)
manquant<-ajoute_nom_station(manquant)

manquant
```

#### Résultats analyses manquants / en plus

A modifier si plusieurs analyses identiques sont commandées pour un même mois.

```{r}


analyses_attendues_bdc$cle <-
  paste0(
    analyses_attendues_bdc$`CODE SANDRE STATION`,
    "_",
    analyses_attendues_bdc$`CODE SANDRE FRACTION`,
    "_",
    analyses_attendues_bdc$`CODE SANDRE PARAMETRE`,
    "_",
    analyses_attendues_bdc$`CODE SANDRE UNITE`,
    "_",
    ifelse(tolower(analyses_attendues_bdc$`ANALYSES IN-SITU`)=="oui",
           "1",
           "2")
  )

synthese_analyses_attendues <-
  analyses_attendues_bdc %>% group_by(cle) %>% count(name = "n_prog")


analyses_xml <-
  analyses_xml %>% ajoute_nom_fraction() %>% ajoute_nom_unite()
analyses_xml$cle <- paste0(
  analyses_xml$CdStationMesureEauxSurface,
  "_",
  analyses_xml$CdFractionAnalysee,
  "_",
  analyses_xml$CdParametre,
  "_",
  analyses_xml$CdUniteMesure,
  "_",
  analyses_xml$CdInsituAna
)

cle_analyses_xml <-
  analyses_xml %>% group_by(cle) %>% count(name = "n_xml")

delta_rendu <- full_join(synthese_analyses_attendues,
                         cle_analyses_xml,
                         by = "cle")

delta_rendu <- delta_rendu %>% replace_na(list(n_xml = 0,
                                               n_prog = 0))
delta_rendu$manquant <- delta_rendu$n_prog - delta_rendu$n_xml

# analyses attendues et absentes du rendu (hors station manquante)
delta_manquant <- delta_rendu %>% subset(manquant > 0)

analyses_manquant <-
  analyses_attendues_bdc %>% 
  subset(cle %in% delta_manquant$cle) %>%
  subset(!(`CODE SANDRE STATION` %in% station_manquant$CdStationMesureEauxSurface))

# analyses rendues et non attendues
delta_enplus <- delta_rendu %>% subset(manquant < 0)

analyses_enplus <-
  analyses_xml %>% 
  subset(cle %in% delta_enplus$cle) %>%
  subset(!(CdStationMesureEauxSurface %in% station_manquant$CdStationMesureEauxSurface))

analyses_enplus<-ajoute_nom_param(analyses_enplus)
```

#### Vérif du code dispositif de collecte

```{r}
   
    # ajout nom reseaux
    anal_reseaux <-
      analyses_xml %>% select(CdStationMesureEauxSurface, CdRdd)
    
    # on détermine le nb max de codes réseaux pour une même analyse
    tmp <-
      gsub("[^//]+", "", anal_reseaux$CdRdd %>%
             unique()) %>%
      nchar() %>%
      max(na.rm = T) + 1
    
    # on split la colonne des codes reseaux pour séparer les codes multiples
    anal_reseaux <-
      separate(
        anal_reseaux,
        col = CdRdd,
        sep = "[//]",
        into = paste0("CdRdd", seq(1:tmp)),
        extra = "drop"
      )
    
    # on transforme le resultat en format long
    anal_reseaux <-
      anal_reseaux %>% pivot_longer(
        cols = paste0("CdRdd", seq(1:tmp)),
        names_to = "numero",
        values_to = "CdRdd",
        values_drop_na = TRUE
      )
    
    # ajout des noms de reseaux
    anal_reseaux <- anal_reseaux %>% ajoute_nom_cdreseaumesure()


summary(anal_reseaux$NomRdd%>%factor)
```

#### Vérif du respect des LQ / accréditations, ... prévues au marché

```{r}
analyses_attendues_bdc$`LIMITE DE QUANTIFICATION GARANTIE PAR PRESTATAIRE`<-analyses_attendues_bdc$`LIMITE DE QUANTIFICATION GARANTIE PAR PRESTATAIRE`%>%as.numeric()

analyses_attendues_bdc$`ACCREDITATION (oui / non)`<-tolower(analyses_attendues_bdc$`ACCREDITATION (oui / non)`)

analyses_attendues_bdc$INCERTITUDE<-analyses_attendues_bdc$INCERTITUDE%>%as.numeric()

# creation d'un tableau qui joint les analyses attendues avec celles rendues

comparatif<-left_join(analyses_attendues_bdc, analyses_xml, by="cle")%>%
  subset(!(`CODE SANDRE STATION` %in% station_manquant$CdStationMesureEauxSurface))

# on extrait du tableau les analyses dont les limites de quantification sont non conformes aux engagements du prestataire
LQ_insuffisante<-comparatif%>%subset(`LIMITE DE QUANTIFICATION GARANTIE PAR PRESTATAIRE`<LqAna) %>% 
  select(
  UG,
  perimetre_facturation,
  `CODE SANDRE STATION`,
  `CODE INTERNE STATION`,
  `NOM STATION`,
  programme,
  `RUN ANALYTIQUE`,
  CdSupport,
  CdFractionAnalysee,
  CdPrelevement,
  DatePrel,
  HeurePrel,
  DateAna,
  HeureAna,
  CdParametre,
  CdUniteMesure,
  `LIMITE DE QUANTIFICATION GARANTIE PAR PRESTATAIRE`,
  LqAna
)

LQ_insuffisante<-LQ_insuffisante%>%
  ajoute_nom_param()%>%
  ajoute_nom_support()%>%
  ajoute_nom_fraction()%>%
  ajoute_nom_unite()

# on extrait du tableau les analyses dont les accréditations sont non conformes aux engagements du prestataire

Accreditation_manquante<-comparatif%>%
  subset(`ACCREDITATION (oui / non)`=="oui" & CdAccreAna != 1) %>% 
  select(
  UG,
  perimetre_facturation,
  `CODE SANDRE STATION`,
  `CODE INTERNE STATION`,
  `NOM STATION`,
  programme,
  `RUN ANALYTIQUE`,
  CdSupport,
  CdFractionAnalysee,
  CdPrelevement,
  DatePrel,
  HeurePrel,
  DateAna,
  HeureAna,
  CdParametre,
  CdUniteMesure,
  CommentairesAna
)

Accreditation_manquante<-Accreditation_manquante%>%
  ajoute_nom_param()%>%
  ajoute_nom_support()%>%
  ajoute_nom_fraction()%>%
  ajoute_nom_unite()


# on extrait du tableau les analyses dont les incertitudes sont non conformes aux engagements du prestataire

Incertitude_non_conforme<-comparatif%>% 
  select(
  UG,
  perimetre_facturation,
  `CODE SANDRE STATION`,
  `CODE INTERNE STATION`,
  `NOM STATION`,
  programme,
  `RUN ANALYTIQUE`,
  CdSupport,
  CdFractionAnalysee,
  CdPrelevement,
  DatePrel,
  HeurePrel,
  DateAna,
  HeureAna,
  CdParametre,
  CdUniteMesure,
  RsAna,
  INCERTITUDE,
  IncertAna,
  CommentairesAna
)%>%subset(IncertAna>INCERTITUDE)
   
  
 Incertitude_non_conforme<-Incertitude_non_conforme%>%
  ajoute_nom_param()%>%
  ajoute_nom_support()%>%
  ajoute_nom_fraction()%>%
  ajoute_nom_unite() 
  
# on extrait du tableau les analyses dont les méthodes sont non conformes aux engagements du prestataire
  
Methode_non_conforme<-comparatif%>% 
  select(
  UG,
  perimetre_facturation,
  `CODE SANDRE STATION`,
  `CODE INTERNE STATION`,
  `NOM STATION`,
  programme,
  `RUN ANALYTIQUE`,
  CdSupport,
  CdFractionAnalysee,
  CdPrelevement,
  DatePrel,
  HeurePrel,
  DateAna,
  HeureAna,
  CdParametre,
  CdUniteMesure,
  `Code méthode SANDRE`,
  Méthode,
  CdMethode,
  CommentairesAna
)%>%subset(`Code méthode SANDRE`!=CdMethode)
  
 Methode_non_conforme<-Methode_non_conforme%>%
  ajoute_nom_param()%>%
  ajoute_nom_support()%>%
  ajoute_nom_fraction()%>%
  ajoute_nom_unite() %>%
   ajoute_nom_methode()


```

## Vérif de la cohérence des résultats d'analyses

S'il existe un historique significatif, les résultats d'une station seront comparés à l'historique pour le paramètre sur cette station.

S'il n'y a pas d'historique significatif, alors la comparaison se fait avec les résultats du même paramètre comparé à l'ensemble des stations.

#### Construction d'une table par station / paramètre / fraction / unité des quantiles 0, 5, 10, 90, 95, 100

On calcule les quantile sur la base des analyses quantifiées (CdrqAna=1) et qualifiées de correctes (CdQualAna=1).

On ajoute l'information sur le nb de données. Seuls les résultats avec au moins 20 données sont pris en compte.

```{r}

analyses_bassin <- readRDS("~/R_Anthony/Naiades/bdd_locale/analyses_bassin.rds")


analyses_bassin$cle_staq_frac_unit<-paste0(analyses_bassin$CdStationMesureEauxSurface,
                                           "_",
                                           analyses_bassin$CdParametre,
                                           "_",
                                           analyses_bassin$CdFractionAnalysee,
                                           "_",
                                           analyses_bassin$CdUniteMesure)



nb_anal <- analyses_bassin %>%
  subset(CdRqAna == "1" & CdQualAna == "1" & !is.na(RsAna)) %>%
  group_by(cle_staq_frac_unit) %>% count %>% subset(n >= 20)

table_stat_analyses <-analyses_bassin %>% 
  subset(cle_staq_frac_unit %in% nb_anal$cle_staq_frac_unit) %>%
  group_by(cle_staq_frac_unit) %>% 
  dplyr::summarise(minST=min(RsAna,na.rm=TRUE),
                   Q5ST=quantile(RsAna, 0.05,na.rm=TRUE),
                   Q10ST=quantile(RsAna, 0.1,na.rm=TRUE),
                   Q90ST=quantile(RsAna, 0.9,na.rm=TRUE),
                   Q95ST=quantile(RsAna, 0.95,na.rm=TRUE),
                   maxST=max(RsAna,na.rm=TRUE),
                   sdST=abs(sd(RsAna, na.rm=TRUE)))

```

#### Construction d'une table par paramètre / fraction / unité des quantiles 0, 1, 5, 10, 90, 95, 99, 100

De même que la table par station, on construit une table pour l'ensemble des stations.

```{r}

analyses_bassin$cle_frac_unit<-paste0(analyses_bassin$CdParametre,
                                           "_",
                                           analyses_bassin$CdFractionAnalysee,
                                           "_",
                                           analyses_bassin$CdUniteMesure)



nb_anal <- analyses_bassin %>%
  subset(CdRqAna == "1" & CdQualAna == "1" & !is.na(RsAna)) %>%
  group_by(cle_frac_unit) %>% count %>% subset(n >= 30)

table_stat_analyses_toutes_staq <-analyses_bassin %>% 
  subset(cle_frac_unit %in% nb_anal$cle_frac_unit) %>%
  group_by(cle_frac_unit) %>% 
  dplyr::summarise(min=min(RsAna,na.rm=TRUE),
                   Q1=quantile(RsAna, 0.01,na.rm=TRUE),
                   Q5=quantile(RsAna, 0.05,na.rm=TRUE),
                   Q10=quantile(RsAna, 0.1,na.rm=TRUE),
                   Q90=quantile(RsAna, 0.9,na.rm=TRUE),
                   Q95=quantile(RsAna, 0.95,na.rm=TRUE),
                   Q99=quantile(RsAna, 0.99,na.rm=TRUE),
                   max=max(RsAna,na.rm=TRUE),
                   sd=abs(sd(RsAna, na.rm=TRUE)))

```

## Algorithme de classement des résultats (codes remarques = 1)

```{r}
analyses_xml$cle_frac_unit<-paste0(analyses_xml$CdParametre,
                                           "_",
                                           analyses_xml$CdFractionAnalysee,
                                           "_",
                                           analyses_xml$CdUniteMesure)

analyses_xml$cle_staq_frac_unit<-paste0(analyses_xml$CdStationMesureEauxSurface,
                                           "_",
                                           analyses_xml$CdParametre,
                                           "_",
                                           analyses_xml$CdFractionAnalysee,
                                           "_",
                                           analyses_xml$CdUniteMesure)
```

##### Probabilité de bon résultat - critère par station

-   si le résultat est entre le Q10 et Q90 du tableau "table_stat_analyses" --\> très probablement correct (classe 1)

-   si le résultat est entre le Q5 et Q10 ou entre le Q90 et Q95 du tableau "table_stat_analyses" --\> probablement correct (classe 2)

-   Si le résultat est entre le min et Q5 ou entre le Q95 et max du tableau "table_stat_analyses" --\> possiblement correct (classe 3)

-   Si le résultat est entre min - sd (écart type) et min ou entre max et max + sd du tableau "table_stat_analyses" --\> incertain (classe 7)

-   Si le résultat est entre min-2sd et min-sd ou entre max + sd et max + 2 sd du tableau "table_stat_analyses" --\> incorrect (classe 9)

-   Au delà -\> incorrect (classe 10)

-   Absence de donnée dans le tableau "table_stat_analyses" --\> classe 0

```{r}
verif <- analyses_xml %>%
  left_join(table_stat_analyses, by = "cle_staq_frac_unit") %>%
  left_join(table_stat_analyses_toutes_staq, by = "cle_frac_unit") %>%
  subset(CdRqAna == "1")

verif$classement_par_station <- 99

# classe 1
verif$classement_par_station <-
  ifelse(verif$RsAna >= verif$Q10ST &
           verif$RsAna <= verif$Q90ST,
         1,
         verif$classement_par_station)

# classe 2
verif$classement_par_station <- ifelse(
  (verif$RsAna >= verif$Q5ST & verif$RsAna < verif$Q10ST) |
    (verif$RsAna <= verif$Q95ST &
       verif$RsAna > verif$Q90ST),
  2,
  verif$classement_par_station
)

# classe 3
verif$classement_par_station <- ifelse(
  (verif$RsAna >= verif$minST & verif$RsAna < verif$Q5ST) |
    (verif$RsAna <= verif$maxST &
       verif$RsAna > verif$Q95ST),
  3,
  verif$classement_par_station
)

# classe 7
verif$classement_par_station <- ifelse(
  (
    verif$RsAna >= (verif$minST - verif$sdST) &
      verif$RsAna < verif$minST
  ) |
    (
      verif$RsAna <= (verif$maxST + verif$sdST) &
        verif$RsAna > verif$maxST
    ),
  7,
  verif$classement_par_station
)

# classe 9
verif$classement_par_station <- ifelse(
  (
    verif$RsAna >= (verif$minST - 2 * verif$sdST) &
      verif$RsAna < (verif$minST - verif$sdST)
  ) |
    (
      verif$RsAna <= (verif$maxST + 2 * verif$sdST) &
        verif$RsAna > (verif$maxST + verif$sdST)
    ),
  9,
  verif$classement_par_station
)

# classe 10
verif$classement_par_station <- ifelse((verif$RsAna <= (verif$minST - 2 *
                                                         verif$sdST)) |
                                         (verif$RsAna >= (verif$maxST + 2 * verif$sdST)),
                                       10,
                                       verif$classement_par_station)

# classe 0
verif$classement_par_station <-
  ifelse(is.na(verif$classement_par_station),
         0,
         verif$classement_par_station)


```

##### Probabilité de bon résultat - critère ensemble des stations

-   si le résultat est entre le Q10 et Q90 du tableau "table_stat_analyses_toutes_staq" --\> très probablement correct (classe 2)

-   si le résultat est entre le Q5 et Q10 ou entre le Q90 et Q95 du tableau "table_stat_analyses_toutes_staq" --\> probablement correct (classe 3)

-   Si le résultat est entre le Q1 et Q5 ou entre le Q95 et Q99 du tableau "table_stat_analyses_toutes_staq" --\> possiblement correct (classe 4)

-   Si le résultat est entre le min et Q1 ou entre le Q99 et max du tableau "table_stat_analyses_toutes_staq" --\> possiblement correct (classe 6)

-   Si le résultat est entre min - sd et min ou entre max et max + sd du tableau "table_stat_analyses_toutes_staq" --\> incertain (classe 8)

-   Au delà -\> incorrect (classe 10)

-   Absence de donnée dans le tableau "table_stat_analyses_toutes_staq" --\> classe 0

```{r}

verif$classement_toutes_station <- 99

# classe 2
verif$classement_toutes_station <-
  ifelse(verif$RsAna >= verif$Q10 &
           verif$RsAna <= verif$Q90,
         2,
         verif$classement_toutes_station)

# classe 3
verif$classement_toutes_station <- ifelse(
  (verif$RsAna >= verif$Q5 & verif$RsAna < verif$Q10) |
    (verif$RsAna <= verif$Q95 &
       verif$RsAna > verif$Q90),
  3,
  verif$classement_toutes_station
)

# classe 4
verif$classement_toutes_station <- ifelse(
  (verif$RsAna >= verif$Q1 & verif$RsAna < verif$Q5) |
    (verif$RsAna <= verif$Q99 &
       verif$RsAna > verif$Q95),
  4,
  verif$classement_toutes_station
)

# classe 6
verif$classement_toutes_station <- ifelse(
  (verif$RsAna >= verif$min & verif$RsAna < verif$Q1) |
    (verif$RsAna <= verif$max &
       verif$RsAna > verif$Q99),
  6,
  verif$classement_toutes_station
)

# classe 8
verif$classement_toutes_station <- ifelse(
  (
    verif$RsAna >= (verif$min - verif$sd) &
      verif$RsAna < verif$min
  ) |
    (
      verif$RsAna <= (verif$max + verif$sd) &
        verif$RsAna > verif$max
    ),
  8,
  verif$classement_toutes_station
)


# classe 10
verif$classement_toutes_station <- ifelse((verif$RsAna <= (verif$min - 
                                                         verif$sd)) |
                                         (verif$RsAna >= (verif$max + verif$sd)),
                                       10,
                                       verif$classement_toutes_station)

# classe 0
verif$classement_toutes_station <-
  ifelse(is.na(verif$classement_toutes_station),
         0,
         verif$classement_toutes_station)


```

##### Agrégation des tests

Le résultat des deux tests précédents sont agrégés selon les règles suivantes :

![Règles d'aggrégation des tests par stations et pour toutes les stations](r%C3%A8gles%20agr%C3%A9gation%20tests%20pour%20classement%20automatique%20r%C3%A9sultats.JPG)

Codes de qualification (<https://www.sandre.eaufrance.fr/definition/ALQ/2.2/QualAna>)

Code ! Mnémonique ! Libellé ---------------------------------------------------------------------- 0 ! non définissable ! Qualification non définissable 1 ! Correcte ! Correcte 2 ! Incorrecte ! Incorrecte 3 ! Incertaine ! Incertaine 4 ! Non qualifié ! Non qualifié

```{r}

verif$classement<-ifelse(verif$classement_toutes_station==0 & verif$classement_par_station==0, 3,4)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(2,3,4) & verif$classement_par_station%in%c(0,1,2), 1,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(2,3) & verif$classement_par_station%in%c(3), 1,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(6) & verif$classement_par_station%in%c(3), 1,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(6) & verif$classement_par_station%in%c(0,1,2,3,7), 3,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(4) & verif$classement_par_station%in%c(3,7), 3,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(3) & verif$classement_par_station%in%c(7), 3,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(2) & verif$classement_par_station%in%c(7,9), 3,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(8,10), 2,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(3,4,6) & verif$classement_par_station%in%c(9,10), 2,verif$classement)

verif$classement<-ifelse(verif$classement_toutes_station%in%c(2) & verif$classement_par_station%in%c(10), 2,verif$classement)


tmp<-verif%>%select(CdParametre, RsAna, classement_par_station:last_col())%>%ajoute_nom_param()
```

## Algorithme de classement des résultats (codes remarques = 10)

## Contrôles interparamètres

#### O2 dissous, saturation en O2 et température

#### NGL, NO3, NO2, NH4, NTK

#### Ptotal et PO4

#### Glyphosate et sulfosate

#### Métolachlore total et ses formes

#### Balance ionique

## Validation "manuelle" des opérations automatiquement classées incertaines ou incorrectes

Affichage du résultat par rapport à l'évolution du paramètre sur la station

Affichage des résultats pour une sélection d'autres paramètres

Affichage du résultat pour le paramètre et d'autres stations dans le fichier de résultat vs reste des analyses

```{sql}

```
